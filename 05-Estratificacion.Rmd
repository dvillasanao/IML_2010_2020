# M√©todo de estratificaci√≥n  {.unlisted .unnumbered}

### Identificaci√≥n de datos at√≠picos {-}   

Para hacer cumplir la definici√≥n de los l√≠mites en el m√©todo de estratificaci√≥n [v√©ase: `M√©todo de estratificaci√≥n de Dalenius & Hodges`] y el n√∫mero √≥ptimo de clases basados en la media aritm√©tica, es importante la identificaci√≥n de datos at√≠picos porque podr√≠an ocasionar resultados poco adecuados. Para contrarrestar este problema, `Hubert y Vandervieren (2007)` proponen el m√©todo de caja, el cual toma en cuenta el grado de asimetr√≠a de un conjunto de datos.  

$$\left[Q_{1} - 1.5e^{-4MC} IQR; \hspace{0.5cm}  Q_{3} + 1.5e^{-4MC} IQR \right] \text{para } MC \geq 0$$
$$\left[Q_{1} - 1.5e^{-3MC} IQR; \hspace{0.5cm}  Q_{3} + 1.5e^{-3MC} IQR \right] \text{para } MC < 0$$
donde:   
$\circ \:ùëÑ_{1}$ ùë¶ $ùëÑ_{3}$: hacen referencia al primer y tercer cuartil, respectivamente; la diferencia entre estos dos valores da como resultado el valor de espacio intercuartil ($ùêºùëÑùëÖ$), y    
$\circ \:ùëÄùê∂ (ùëöùëíùëëùëêùëúùë¢ùëùùëôùëí)$: cuantifica el grado de asimetr√≠a de una muestra univariable ${ùë•_1,ùë•_2,‚Ä¶ ,ùë•_ùëõ}$.     

Se identifican los valores at√≠picos para cada conjunto de datos para cada a√±o. 

- Se itera sobre cada elemento de la lista `tablas` que corresponden a los a√±os `2010` y `2020`. 
- Se calculan los estad√≠sticos de la columna del √≠ndice de marginaci√≥n para cada conjunto de datos $DP2_{i}$ correspondientes al a√±o y se asigna el resultado a una nueva variable denominada $outliers_i$.    

```{r}
for(i in tablas){
  assign(paste0("outliers_", i), boxplot.stats(get(paste0("DP2_", i))[,18]))
}
```

Se crea un data.frame que contiene el n√∫mero de valores at√≠picos, su rango y el l√≠mite inferior para cada conjunto de datos.   

```{r, echo = FALSE}
#L√≠mites para el c√°lculo de estratificaci√≥n a nivel localidad, 2010 - 2020
p <- NULL
for(i in tablas){
p[[paste0(i)]] <- data.frame(n = length(get(paste0("outliers_", i))$out), 
                             rango = range(get(paste0("outliers_", i))$out), 
                             lim = get(paste0("outliers_", i))$stats[1])
}
```

```{r, echo = FALSE}
tabla <- data.frame(outliers = p[["2010"]][["n"]][1],
                    minimo = p[["2010"]][["rango"]][1],
                    maximo = p[["2010"]][["rango"]][2])   
tabla %>% 
 gt() %>%
   tab_header(title = "L√≠mites para el c√°lculo de estratificaci√≥n a nivel localidad, 2010") %>%
    fmt_number(columns = c(2:3), decimals = 3) %>%
    tab_options(heading.title.font.size = 14, 
                heading.subtitle.font.size = 12,
                table.font.names = 'Century Gothic',
                table.align = "center",
                table.font.size = 10,
                data_row.padding = px(1)) %>%
    tab_style(style = list(cell_text(align = "left",
                                      weight = 'bold')),
               locations = list(cells_title(groups = c("title")))) %>%
     tab_style(style = list(cell_text(align = "left")),
                locations = list(cells_title(groups = c("subtitle")))) %>%  
      cols_label(outliers = md("**Valores at√≠picos**"), 
                minimo = md("**M√≠nimo**"),
                maximo = md("**L√≠mite**")) %>%
       tab_spanner(label = "Rango",
                   columns = c(minimo, maximo)) %>%
         as_raw_html() 
```

```{r, echo = FALSE}
tabla <- data.frame(outliers = p[["2020"]][["n"]][1],
                    minimo = p[["2020"]][["rango"]][1],
                    maximo = p[["2020"]][["rango"]][2])   
tabla %>% 
 gt() %>%
   tab_header(title = "L√≠mites para el c√°lculo de estratificaci√≥n a nivel localidad, 2020") %>%
    fmt_number(columns = c(2:3), decimals = 3) %>%
    tab_options(heading.title.font.size = 14, 
                heading.subtitle.font.size = 12,
                table.font.names = 'Century Gothic',
                table.align = "center",
                table.font.size = 10,
                data_row.padding = px(1)) %>%
    tab_style(style = list(cell_text(align = "left",
                                      weight = 'bold')),
               locations = list(cells_title(groups = c("title")))) %>%
     tab_style(style = list(cell_text(align = "left")),
                locations = list(cells_title(groups = c("subtitle")))) %>%  
      cols_label(outliers = md("**Valores at√≠picos**"), 
                minimo = md("**M√≠nimo**"),
                maximo = md("**L√≠mite**")) %>%
       tab_spanner(label = "Rango",
                   columns = c(minimo, maximo)) %>%
         as_raw_html() 
```



Se identifican los casos extremos en el √≠ndice de marginaci√≥n y se aplica el m√©todo de caja propuesto por `Hubert y Vandervieren`, concluyendo los l√≠mites con los que se debe trabajar.      

Se a√±ade una nueva columna `IM_out`. Esta columna se calcula usando `if_else`, de la siguiente manera:   

- Si el valor de IM es mayor o igual al l√≠mite inferior de los valores no considerados outliers `(get(paste0("outliers_", i))$stats[1])`, entonces `IM_out` toma el valor de `IM`.   
- Si el valor de IM es menor que el l√≠mite inferior, entonces `IM_out` toma el valor del l√≠mite inferior, eliminando as√≠ los outliers.      

```{r}
## Se crea un √≠ndice ficticio, en la que se quitan los outliers   
for(i in tablas){
assign(paste0("DP2_", i), get(paste0("DP2_", i)) %>% 
                            mutate(IM = get(paste0("IM_", i))) %>%
                             mutate(IM_out = if_else(.$IM >= get(paste0("outliers_", i))$stats[1],
                                                      .$IM,
                                                        get(paste0("outliers_", i))$stats[1])) %>%
                              select(-paste0("IM_", i))
  )
}
```


### M√©todo de estratificaci√≥n de Dalenius & Hodges {-}

`strata.cumrootf`: cumulative root frequency method by Dalenius and Hodges (1959). 

Con la obtenci√≥n del √≠ndice de marginaci√≥n a trav√©s del m√©todo DP2, los valores se clasificaron en cinco categor√≠as ordinales con el m√©todo de Dalenius y Hodges (1959), para obtener el grado de marginaci√≥n. Este m√©todo forma estratos de manera que la varianza sea m√≠nima al interior de cada estrato y m√°xima entre cada uno de ellos, es decir, son lo m√°s homog√©neos posibles. Este procedimiento utiliza la ra√≠z de las frecuencias acumuladas para la construcci√≥n de los estratos, por lo que se lleva a cabo para la divisi√≥n de la poblaci√≥n en el estrato L. Esta es una soluci√≥n aproximada de Dalenius y Hodges (1959) a las ecuaciones de Dalenius (1950). De acuerdo con Gunning y Horgan (2004), el l√≠mite superior de cada estrato se determin√≥ con la siguiente expresi√≥n:  

$$Q = \frac{1}{L}\sum^{J}_{i=1}{\sqrt{f_{i}}}$$

Sea un conjunto de estratos determinados por su l√≠mite superior,

 $$Q,\ 2Q,\ \ldots,\ \left(L-1\right)Q,\ (L)Q.$$
donde:  

$\circ \:J$: es el n√∫mero de clases dentro del grupo de la variable ordenada X,    
$\circ \:f_{i}\ \in(1,\ \ldots, J)$: es la frecuencia en cada clase  $J$, y  
$\circ \:L$: es el n√∫mero de estratos.   


La eficiencia del m√©todo de la ra√≠z de las frecuencias acumuladas depende principalmente del n√∫mero de clases dentro del grupo de la variable ordenada. Sin embargo, no hay un procedimiento est√°ndar sobre c√≥mo elegir el mejor valor para el n√∫mero de clases, siendo esto una limitante del m√©todo de Dalenius y Hodges. Para medir el efecto del n√∫mero  de clases en la varianza de cada estrato se recurri√≥ a un m√©todo iterativo para obtener un criterio de agrupaci√≥n √≥ptimo.    

Para establecer los l√≠mites de los estratos $(b_{1},\ \ldots,\ b_{L})$ que minimicen la varianza del estimador, se utiliza la asignaci√≥n de Neyman para determinar el tama√±o de muestra √≥ptimo. Sea la varianza del estimador:    

$$V\left({\bar{x}}_{st}\right)=\ \sum_{h}\left(\frac{N_h}{N}\right)^2\frac{S_h^2}{n_h}\ $$
donde:

$\circ  \: S_{h}^{2}$: es la varianza poblacional en el estrato $h$,   
$\circ  \:n_{h}$: es el tama√±o de muestra en el estrato $h$ utilizada por la asignaci√≥n de Neyman, y 
$\circ  \:N_{h}$: es el total de elementos en el estrato $h$, sea $N=\sum_{h=1}^{L}{N_{h}}$.     

Si se asume que la distribuci√≥n dentro de cada estrato se distribuye aproximadamente de manera uniforme, los l√≠mites se obtienen tomando intervalos iguales en la funci√≥n de la ra√≠z de las frecuencias acumuladas. Los l√≠mites se resuelven de manera iterativa:   

$$\frac{S_h^2+(b_h-{\bar{X}}_h)2}{S_h}=\frac{S_{h+1}^2+(b_h-{\bar{X}}_{h+1})2}{S_{h+1}}\ para\ h=1,\ \ldots.\ ,\ L-1$$
donde:

$\circ  \: b_{h}$: es el l√≠mite superior en el estrato $h$,   
$\circ  \: {\bar{X}}_{h}$: es la media poblacional en el estrato $h$, y   
$\circ  \: S_{h}^{2}$: es la varianza poblacional en el estrato $h$.      

El requisito de precisi√≥n, generalmente se establece cuando el coeficiente de variaci√≥n sea igual a un nivel especificado entre 1 y 10 por ciento (Hidiroglou y Kozak, 2018).     

## N√∫mero √≥ptimo de clases del m√©todo de Dalenius & Hodge {-}  

`alloc` lista que especifica el esquema de asignaci√≥n. La lista debe contener 3 n√∫meros para los 3 exponentes q1, q2 y q3 en el esquema de asignaci√≥n general (ver paquete de `stratification`). El valor predeterminado es la asignaci√≥n de **Neyman** (q1 = q3 = 0.5 y q2 = 0)   

A continuaci√≥n, se realiza un an√°lisis de estratificaci√≥n sobre los diferentes a√±os, usando la funci√≥n `strata.cumrootf()`, almacenando los resultados de errores est√°ndar, medias y varianzas en matrices que luego se guardan en listas.    

```{r, results=FALSE, warning=FALSE, eval = FALSE}
iteraciones <- 1000
start.time <- Sys.time()
DH_Localidad <- list()
stderr <- list()
mean <- list()
var <- list()
for(j in 1:2){
i <- 1
  sd <- matrix(NA, nrow = (iteraciones), ncol = 3)
  meanh <- matrix(NA, nrow = (iteraciones), ncol = 6)
  varh <- matrix(NA, nrow = (iteraciones), ncol = 6)
 for(n in seq(5, (iteraciones), 1)){
      DH_Localidad[[paste(tablas[j])]][[n]] <- strata.cumrootf(x = get(paste0("DP2_", tablas[j]))[,19], CV = 0.05, Ls = 5, alloc = c(0.5, 0, 0.5), nclass = n)
      cum <- DH_Localidad[[paste(tablas[j])]][[n]]
      sd[i,] <-  c(n, cum$stderr, cum$CV)
      meanh[i,] <- c(n, cum$meanh)
      varh[i,] <-  c(n, cum$varh)
      i <- i + 1
}
  stderr[[j]] <- sd
  mean[[j]] <- meanh
  var[[j]] <- varh
}

for(i in 1:2){
  colnames(stderr[[i]]) <- c("n", "sderr", "CV")
}

end.time <- Sys.time()
time.taken <- round(end.time - start.time, 2)
time.taken
```


```{r, echo = FALSE}
#saveRDS(stderr, file = paste0(here::here(), "/Output/stderr.RDS"))
stderr <- readRDS(file = paste0(here::here(), "/Output/stderr.RDS"))
```



#### N√∫mero √≥ptimo de clases {-} 

Se toma cada matriz resultante de errores est√°ndar de la lista `stderr`, y luego selecciona la fila que tiene el coeficiente de variaci√≥n (`CV`) m√°s bajo. Estos resultados se almacenan en la lista `min.strata`, la cual contendr√° los data.frames correspondientes a las filas con el menor `CV `para cada uno de los tres conjuntos de datos en `stderr`.


```{r}
min.strata <- NULL
for(i in 1:2){
  min.strata[[i]] <- stderr[[i]] %>%
                      as.data.frame() %>% 
                       slice(which.min(.$CV))
}
```

```{r, echo = FALSE}
tabla <- do.call(rbind.data.frame, min.strata) %>%
          dplyr::mutate(ANIO = tablas) %>%
           relocate(ANIO, .before = "n")

tabla %>% 
 rename("A√ëO" = "ANIO") %>%
  gt() %>%
   tab_header(title = "N√∫mero √≥ptimo de clases") %>%
    fmt_integer(columns = names(tabla)[2]) %>%
     fmt_number(columns = names(tabla)[3:4],
                decimals = 2) %>%
       tab_options(heading.title.font.size = 14, 
                   heading.subtitle.font.size = 12,
                   table.font.names = 'Century Gothic',
                   table.align = "center",
                   table.font.size = 10) %>%
        tab_style(style = list(cell_text(align = "left",
                                          weight = 'bold')),
                   locations = list(cells_title(groups = c("title")))) %>%
         tab_style(style = list(cell_text(align = "left")),
                    locations = list(cells_title(groups = c("subtitle")))) %>%
          cols_label(A√ëO = md("**A√ëO**"),
                     n = md("**n**"),
                     sderr = md("**sd**"),
                     CV = md("**C.V.**")) %>%
           as_raw_html() 
```



```{r, echo = FALSE, results=FALSE, out.width='80%'}
p <- NULL
for(i in 1:2) {
p[[i]] <- stderr[[i]] %>%
           as.data.frame() %>%
            arrange(desc(.$CV)) %>%
             mutate(count = seq(1, nrow(stderr[[i]]))) %>%
              ggplot() + 
               geom_point(aes(x = count, y = CV)) + 
                geom_line(aes(x = count, y = CV)) +
                 geom_text(data = min.strata[[i]], aes(label = paste0("CV = ", round(CV, 4)), x = iteraciones - 75, y = CV), 
                           vjust = -1,
                            size = 6,
                             color = "red",
                              family = "Century Gothic") +
                  geom_hline(data = min.strata[[i]], aes(yintercept = CV), color = "red") +
                   theme_minimal() + 
                    theme(title = element_text(family = "Century Gothic"), 
                          plot.title = element_text(size = 22, family = "Century Gothic"),
                          plot.subtitle = element_text(size = 20, family = "Century Gothic"),
                          axis.text = element_text(size = 14, family = "Century Gothic"),
                          axis.title = element_text(size = 18, family = "Century Gothic")) + 
                     scale_y_continuous(labels = scales::number_format(accuracy = 0.01)) +
                 labs(title = "Coeficiente de variaci√≥n √≥ptimo",
                       subtitle = paste(tablas[i]),
                        y = "CV", 
                         x = "iteraciones") 
}
```

<a href="https://raw.githubusercontent.com/dvillasanao/IML_2010-2020/main/img/iteraciones.png" data-lightbox="image-1" data-title="iteraciones">
```{r, echo = FALSE, fig.width=12, fig.height=12, out.width='100%'}
knitr::include_graphics(paste0(here::here(), "/img/iteraciones.png"))
```
</a>

Se toman en cuenta el n√∫mero de clases que salen del los resultados del m√©todo iterativo. Utilizando la funci√≥n `strata.cumrootf()` de la paqueter√≠a `stratification` con par√°metros espec√≠ficos y el n√∫mero de clases (`nclass`) obtenido de `min.strata`.       
- `CV = 0.05`: Establece el coeficiente de variaci√≥n.   
- `Ls = 5`: Establece el n√∫mero de estratos.   
- `alloc = c(0.5, 0, 0.5)`: Define la asignaci√≥n para la estratificaci√≥n.    
- `nclass = min.strata[[i]][,1]`: Establece el n√∫mero de clases utilizando el primer valor de la fila con el menor CV en `min.strata`.   

```{r}
for(i in 1:2){
  assign(paste0("strata.DP2_", tablas[i]), strata.cumrootf(get(paste0("DP2_", tablas[i]))[,19],
                                                            CV = 0.05,
                                                             Ls = 5,
                                                              alloc = c(0.5, 0, 0.5), 
                                                               nclass = min.strata[[i]][,1]))
}
```

Se agregan los datos a la base original.  

```{r}
##Se agrega a la base DP2
for(i in 1:2){
  assign(paste0("DP2_", tablas[i]), data.frame(get(paste0("DP2_", tablas[i])) %>% 
                                                select(-IM_out),   # Se quita el √≠ndice ficticio
                                                 get(paste0("strata.DP2_", tablas[i]))[["stratumID"]]))
}

# Se cambian los nombres de las columnas 
for(i in 1:2){
  columns = get(paste0("DP2_", tablas[i]))
  colnames(columns) = c("CVE_LOC", "ENT", "NOM_ENT", "MUN", "NOM_MUN", "LOC", "NOM_LOC", "POB_TOT", "ANIO",
                        "ANALF", "SBASC", "OVSDE", "OVSEE", "OVSAE", "OVPT", "OVHAC", "OVSREF",
                        paste0("IM_", tablas[i]), paste0("GM_", tablas[i]))
  assign(paste0("DP2_", tablas[i]), columns)
  rm(columns)
}

# Se cambian los levels a los grados de marginaci√≥n correspondientes
for(i in tablas){
  niveles = get(paste0("DP2_", i)) 
  levels(niveles[,19]) = c("Muy alto", "Alto", "Medio", "Bajo", "Muy bajo")
  assign(paste0("DP2_", i), niveles)
}
```


### L√≠mites de los estratos {-}

Se crea un data frame llamado `limites` que contiene los l√≠mites de ciertos intervalos para los a√±os `2010` y `2020`. Cada columna contiene una combinaci√≥n de:   
- El valor m√≠nimo del √≠ndice de marginaci√≥n (`IM:`) para el a√±o correspondiente.  
- Los valores de los l√≠mites de los estratos (`bh`) calculados previamente.  
- El valor m√°ximo del √≠ndice de marginaci√≥n (`IM_`) para el a√±o correspondiente.      

```{r}
limites <- data.frame("2010" = c(min(DP2_2010$IM_2010), strata.DP2_2010$bh, max(DP2_2010$IM_2010)),
                      "2020" = c(min(DP2_2020$IM_2020), strata.DP2_2020$bh, max(DP2_2020$IM_2020)))
```


```{r, echo = FALSE}
tabla <- limites %>%
          t()  %>%
           as.data.frame() %>%
            mutate_if(is.numeric, round, digits = 2) %>%
             tibble::rownames_to_column(.data = .) %>% 
              mutate(ANIO = c("2010", "2020"),
                     `Muy alto` = paste("[", V1, "-", V2, "]"),
                     `Alto` = paste("(", V2, "-", V3, "]"),
                     `Medio` = paste("(", V3, "-", V4, "]"),
                     `Bajo` = paste("(", V4, "-", V5, "]"),
                     `Muy bajo` = paste("(", V5, "-", V6, "]")) %>%
               select(., c(8:13))

tabla %>% 
 rename("A√ëO" = "ANIO") %>%
  gt(rowname_col = c("A√ëO")) %>%
   tab_header(title = "L√≠mite de los estratos") %>%
    tab_options(heading.title.font.size = 14, 
                heading.align = "center",
                heading.subtitle.font.size = 12,
                table.align = "center",
                table.font.names = 'Century Gothic',
                table.font.size = 10) %>%
     tab_style(style = list(cell_text(align = "center",
                                       weight = 'bold')),
                locations = list(cells_title(groups = c("title")))) %>%
      cols_label(A√ëO = md("**A√ëO**"), 
                 `Muy alto` = md("**Muy alto**"),
                 `Alto` = md("**Alto**"),
                 `Medio` = md("**Medio**"),
                 `Bajo` = md("**Bajo**"),
                 `Muy bajo` = md("**Muy bajo**")) %>%
      as_raw_html() 
```


