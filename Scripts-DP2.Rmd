--- 
title: "Índice de marginación a nivel localidad 2010 - 2020"
author: "Diana Villasana Ocampo"
site: bookdown::bookdown_site
documentclass: book
bibliography: [book.bib, packages.bib]
url: 'https://github.com/dvillasanao/IML_2010_2020'
# cover-image: path to the social sharing image like images/cover.jpg
description: |
  This is a minimal example of using the bookdown package to write a book.
  The HTML output format for this example is bookdown::bs4_book,
  set in the _output.yml file.
  
biblio-style: apalike
csl: chicago-fullnote-bibliography.csl
---
```{r include=FALSE, cache=FALSE}
# example R options set globally
options(width = 80)

# example chunk options set globally
knitr::opts_chunk$set(
  comment = "#>",
  collapse = TRUE,
  message = FALSE,
  warning = FALSE
  )
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
setwd(here::here())

```

# Índice de marginación a nivel localidad  {.unlisted .unnumbered}

El índice de marginación elaborado por el Consejo Nacional de Población (`CONAPO`) se ha convertido en una herramienta esencial para analizar y medir las condiciones socioeconómicas en México, particularmente a nivel loacalidad. Este índice, desde su primera publicación en 1990, ha sido fundamental para identificar y cuantificar las desigualdades y disparidades que existen entre diferentes regiones del país.   

**Historia y Evolución**:     

- Décadas de `1970` y `1980`: Comienzo de los primeros ejercicios de medición de desigualdad.   
- `1990`: Primera publicación del índice de marginación utilizando el Análisis de Componentes Principales (ACP). Aunque útil, este método no permitía comparaciones temporales.   
- Demanda de Comparabilidad: La necesidad de evaluar la evolución de la marginación a lo largo del tiempo llevó a una revisión metodológica.     

**Cambio Metodológico**:   

- Nueva Técnica: En 2020, se adoptó la técnica de Distancias Ponderadas al Cuadrado para mejorar la comparabilidad temporal y la precisión de los datos.   
- Ajustes en Indicadores: Se realizaron modificaciones para alinear el índice con las recomendaciones de organismos nacionales e internacionales.  
- Método de Estratificación: Se continuó utilizando la técnica de estratificación de Dalenius y Hodges para el cálculo de los estratos del índice.    

**Impacto y Futuro**:   

El índice de marginación tiene como objetivo proporcionar información objetiva y cuantitativa sobre las disparidades socioeconómicas entre los municipios. Esta información es crucial para la toma de decisiones en políticas públicas, permitiendo una asignación más efectiva de recursos y esfuerzos para reducir la marginación y promover un desarrollo equitativo.    

Las variables consideradas en el índice incluyen el nivel educativo, acceso a servicios de salud, infraestructura básica, vivienda, ingresos y ocupación. Estas variables se agrupan en dimensiones que reflejan el grado de marginación de cada municipio. Un índice de marginación más bajo indica mejores condiciones de desarrollo humano y bienestar.    

A lo largo de las décadas, el índice ha evolucionado significativamente en términos de metodología y actualización de datos, gracias a los avances tecnológicos y el acceso a información geoespacial. Desde su creación hasta el presente, el índice ha permitido identificar tendencias y cambios en las condiciones socioeconómicas de las regiones del país, destacando tanto áreas de mejora como zonas que aún enfrentan desafíos considerables en términos de marginación y pobreza.    

Este índice sigue siendo una herramienta crucial para identificar las mejores prácticas y generar estrategias de intervención focalizadas en las áreas que más lo necesitan, con el fin de mejorar las condiciones de vida de la población mexicana.  

**Base de datos** de los tres años se encuentran disponibles en la página oficial de [CONAPO](https://www.gob.mx/conapo/documentos/indices-de-marginacion-2020-284372)   

**Datos abiertos de México** [datos.gob.mx](https://datos.gob.mx/busca/dataset/indice-de-marginacion-carencias-poblacionales-por-localidad-municipio-y-entidad)   

**Publicación** [Índice De Marginación Por Entidad Federativa Y Municipio 2020](https://www.gob.mx/conapo/documentos/indices-de-marginacion-2020-284372).    

**Índice de marginación a nivel estatal** [Bookdown](https://dvillasanao.github.io/IME_2010_2020/)   
**Índice de marginación a nivel municipal** [Bookdown](https://dvillasanao.github.io/IMM_2010-2020/)   
**Índice de marginación a nivel localidad** [Bookdown](https://dvillasanao.github.io/IML_2010_2020/)   
**Índice de marginación a nivel AGEB** [Bookdown](https://dvillasanao.github.io/IML_2010-2020/)   
**Índice de marginación a nivel Colonia** [Bookdown](https://dvillasanao.github.io/IMC_2020/)        

```{r, include=FALSE}
# automatically create a bib database for R packages
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE, cache = TRUE, 
                       eval = TRUE)
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
setwd(rprojroot::find_rstudio_root_file())
```  

```{r, echo=FALSE, results=FALSE}
#Font Stlye
require(showtext)
library(extrafont)
# activar showtext
windowsFonts()
#Century Gothic
```

```{r, echo = FALSE, results=FALSE}
# Librerías que se usaron en el documento
require(Cairo)
require(ggplot2)
require(ggridges)
require(grDevices)
require(ggpubr)
require(dplyr)
require(p2distance)
require(stratification)
require(knitr)
require(magrittr)
require(kableExtra)
require(openxlsx)
require(tidyverse)
require(readxl)
require(psych)
require(stringr)
require(corrplot)
require(forcats)
require(gt)
require(rgdal)      
require(geojsonio)
require(jsonlite)
require(leaflet)
require(htmlwidgets)
require(leaflet.extras)
require(mapview)
require(leaflet.providers)
```

```{r include=FALSE, eval=FALSE}
# automatically create a bib database for R packages
knitr::write_bib(c(
  .packages(), 'bookdown', 'knitr', 'rmarkdown', 'dp2distance', 'statification', 'corrplot'
), 'packages.bib')
```


```{r, echo = FALSE}
tablas <- c("2010", "2020")

for(i in tablas){
load(file = paste0(here::here(), "/Output/IML_", i, ".RData"))
}

p <- NULL
for(i in 1:2){
nombres <- names(get(paste0("DP2_",tablas[i])))
p[[paste(tablas[i])]] <- get(paste0("DP2_", tablas[i])) %>%
                           group_by(get(nombres[19])) %>%
                             summarise(POB_TOT = sum(get(nombres[8])),
                                       GM = n())
}
p <- do.call(cbind.data.frame, p)

tabla <- p %>%
          select(-c("2020.get(nombres[19])")) %>%
           janitor::adorn_totals(fill = "-", where= "row")

tabla %>% 
 gt() %>%
  tab_header(title = "Nacional: Población y unidades geograficas según el índice de marginación, 2010-2020") %>%
   tab_options(heading.title.font.size = 14, 
               heading.subtitle.font.size = 12,
               table.font.names = 'Century Gothic',
               table.align = "center",
               table.font.size = 10,
               data_row.padding = px(1)) %>%
     tab_style(style = list(cell_text(align = "left",
                                      weight = 'bold')),
               locations = list(cells_title(groups = c("title")))) %>%
     tab_style(style = list(cell_text(align = "left")),
               locations = list(cells_title(groups = c("subtitle")))) %>%
     tab_style(style = list(cell_text(weight = 'bold')),
               locations = cells_body(columns = everything(), rows = tidyselect::last_col())) %>%
      cols_label(`2010.POB_TOT` = md("**Población 2010**"),
                 `2020.POB_TOT` = md("**Población 2020**"),
                 `2010.GM` = md("**Localidades**"),
                 `2020.GM` = md("**Localidades**"),
                 "2010.get(nombres[19])" = md("**Grados**")) %>%
       fmt_integer(columns = c(2:5), sep_mark = " ") %>%
        tab_spanner(label = "2010",
                    columns = c(2:3)) %>%
        tab_spanner(label = "2020",
                    columns = c(4:5)) %>%
         as_raw_html() 
```

<!--chapter:end:index.Rmd-->

```{r include=FALSE, cache=FALSE}
# example R options set globally
options(width = 80)

# example chunk options set globally
knitr::opts_chunk$set(
  comment = "#>",
  collapse = TRUE,
  message = FALSE,
  warning = FALSE
  )
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
setwd(here::here())

```
# Indicadores simples  {.unlisted .unnumbered}

### Porcentaje de población analfabeta de 15 años o más $(I_{1}^{i})$ {-}
	
El indicador se obtiene dividiendo el monto de población de 15 años o más que declaró no saber leer y escribir un recado, entre la diferencia de la población total de 15 años o más y aquellos que no especificaron su condición de alfabetismo:  

$$I_{1}^{i}=\frac{PAN_{15+}^{i}}{P_{15+}^{i}- PNEALF_{15+}^{i}}×100$$

donde:

$PAN_{15+}^{i}$: es la población de 15 años o más analfabeta,   
$P_{15+}^{i}$: es la población total de 15 años o más, y   
$PNEALF_{15+}^{i}$: es la población de 15 años o más que no especificó su condición de alfabetismo.   

### 	Porcentaje de población de 15 años o más sin educación básica $(I_{2}^{i})$ {-}

El indicador mide la magnitud de la población sin educación básica completa. Su cálculo se realiza en dos etapas. En la primera, la población que no especificó su último grado aprobado en secundaria o en estudios técnicos o comerciales con primaria terminada, se distribuye entre la población que aprobó entre uno y dos grados en estos mismos niveles educativos, aplicando la siguiente fórmula:   

$${PSI}_{15+}^{i}={PSCI}_{15+}^i+\left[\frac{{PSCI}_{15+}^i}{{PSCI}_{15+}^i+{PSCC}_{15+}^i}\times{PNEGS}_{15+}^i\right]$$


donde:    

$P{SI}_{15+}^{i}$: es la población de 15 años o más que aprobó entre el primer y segundo grado de secundaria o estudios técnicos o comerciales con primaria terminada con los no especificados de estos niveles educativos ya distribuidos,  
${PSCI}_{15+}^{i}$: es la población de 15 años o más que declaró haber aprobado entre el primer y segundo grado de secundaria o estudios técnicos o comerciales con primaria terminada,  
${PSCC}_{15+}^{i}$: es la población de 15 años o más que cursó el tercer grado en secundaria o tres o cuatro grados en estudios técnicos o comerciales con primaria terminada, y  
${PNEGS}_{15+}^{i}$: es la población de 15 años o más que no especificó su último grado cursado en secundaria o en estudios técnicos o comerciales con primaria terminada.  

Con el dato de la población con estudios truncos en secundaria o en estudios técnicos o comerciales con primaria terminada, se procedió a calcular el indicador de porcentaje de población sin educación básica. Este porcentaje se calcula dividiendo la población de 15 años o más sin educación básica, entre la diferencia de la población total de 15 años o más y aquellos que no especificaron su nivel educativo:   

$$I_{2}^{i}=\frac{{PSIN}_{15+}^i+{PPI}_{15+}^i+{PSI}_{15+}^i}{P_{15+}^i-{PNEIN}_{15+}^i}\times100$$

donde:

${PSIN}_{15+}^{i}$: es la población de 15 años o más sin instrucción,  
${PPI}_{15+}^{i}$: es la población de 15 años o más con algún grado en educación primaria,  
${PSI}_{15+}^{i}$: es la población de 15 años o más con nivel incompleto de secundaria o estudios técnicos o comerciales con primaria terminada,   
$P_{15+}^{i}$: es la población total de 15 años o más, y   
${PNEIN}_{15+}^{i}$: es la población de 15 años o más que no especificó su nivel de instrucción.   


### Porcentaje de ocupantes en viviendas particulares sin drenaje ni sanitario $(I_{3}^{i})$ {-} 

Este porcentaje se obtiene al dividir el número de ocupantes de viviendas particulares sin drenaje ni sanitario, entre el número de ocupantes en viviendas particulares, menos el número de ocupantes de viviendas particulares en donde no se especificó la disponibilidad de drenaje ni sanitario:  

$$I_{3}^{i}=\frac{{OVSDS}^{i}}{{OVP}^{i}-{ONEDS}^{i}}\times100$$


donde:

${OVSDS}^{i}$: son los ocupantes de viviendas particulares sin disponibilidad de drenaje ni sanitario,   
${OVP}^{i}$: es el total de ocupantes en viviendas particulares, y   
${ONEDS}^{i}$: son los ocupantes de viviendas particulares en donde no se especificó la disponibilidad de drenaje ni sanitario.    


### Porcentaje de ocupantes en viviendas particulares sin energía eléctrica $(I_{4}^{i})$ {-}    


Este indicador se obtiene al dividir el número de ocupantes de viviendas particulares sin disponibilidad de energía eléctrica, entre el número de ocupantes en viviendas particulares menos el número de ocupantes de viviendas particulares en donde no se especificó la existencia de luz eléctrica:

$$I_{4}^{i}=\frac{{OSEE}^i}{{OVP}^i-{ONEEE}^i}\times100$$  

donde:  

${OSEE}^{i}$: son los ocupantes de viviendas particulares sin disponibilidad de energía eléctrica,   
${OVP}^{i}$: es el total de ocupantes en viviendas particulares, y   
${ONEEE}^{i}$: es el número de ocupantes de viviendas particulares en donde no se especificó la disponibilidad de energía eléctrica.    


### Porcentaje de ocupantes en viviendas particulares sin agua entubada $(I_{5}^{i})$ {-}     
	
Para obtener este indicador se divide el número de ocupantes en viviendas particulares que no disponen de agua entubada, entre la diferencia del total de ocupantes en viviendas particulares y el total de ocupantes en viviendas en donde no se especificó la disponibilidad de agua entubada:   

$$I_{5}^{i}=\frac{{OSAE}^i}{{OVP}^i-{ONEAE}^i}\times100$$  

donde:  

${OSAE}^{i}$: son los ocupantes de viviendas particulares sin disponibilidad de agua entubada,  
${OVP}^{i}$: es el total de ocupantes en viviendas particulares, y   
${ONEAE}^{i}$: son los ocupantes de viviendas particulares en donde no se especificó la disponibilidad de agua entubada.  


### Porcentaje de ocupantes en viviendas particulares con piso de tierra $(I_{6}^{i})$ {-} 

En este indicador se identifican los ocupantes de viviendas particulares con piso de tierra y se divide entre el total de ocupantes en viviendas particulares, menos el número de ocupantes de viviendas particulares en donde no se especificó el material predominante en pisos:    

$$I_{6}^{i}=\frac{{OPT}^i}{{OVP}^i-{ONEMP}^i}\times100$$   

donde:   

${OPT}^{i}$: son los ocupantes de viviendas particulares con piso de tierra,    
${OVP}^{i}$: es el total de ocupantes en viviendas particulares, y   
${ONEMP}^{i}$: son los ocupantes de viviendas particulares en las que no se especificó el material predominante en pisos.    

### Porcentaje de ocupantes en viviendas particulares con hacinamiento $(I_{7}^{i})$ {-}  

El procedimiento para el cálculo de este indicador constó de dos etapas. Primero, en cada vivienda particular habitada se dividió el número de ocupantes entre el número de cuartos dormitorio, para identificar las viviendas con hacinamiento:   

$$OVHAC=\frac{OVP}{CDVP}$$
donde:

$VHAC$: es la vivienda con hacinamiento,   
$OVP$: es el número de ocupantes que residen habitualmente una vivienda particular, y   
$CDVP$: es el número de cuartos dormitorio en una vivienda particular.   
	
En la segunda fase de cálculo, se dividió el número de ocupantes en viviendas particulares con hacinamiento, entre el total de ocupantes en viviendas particulares habitadas menos el número de ocupantes en viviendas particulares habitadas donde no se especificó el número de cuartos dormitorio:     

$$I_{7}^{i}=\frac{O{VHAC}^i}{{OVP}^i-{ONECD}^i}\times100$$    

donde:

${OVHAC}^{i}$: son los ocupantes en viviendas particulares con hacinamiento,   
${OVP}^{i}$: es el total de ocupantes en viviendas particulares, y   
${ONECD}^{i}$: son los ocupantes en viviendas particulares en donde no se especificó el número de cuartos dormitorio.     

### Porcentaje de ocupantes en viviendas particulares sin refrigerador $(I_{8}^{i})$ {-}  
	
En este indicador se identifican los ocupantes en viviendas particulares que no disponen de refrigerador y se divide entre el total de ocupantes en viviendas particulares menos los ocupantes en viviendas particulares que no especificaron la disponibilidad de refrigerador:

$$I_{8}^{i}=\frac{{OSR}^i}{{OVP}^i-{ONER}^i}\times100$$  

donde:   

${OSR}^{i}$: son los ocupantes de viviendas particulares sin disponibilidad de refrigerador,     
${OVP}^{i}$: es el total de ocupantes en viviendas particulares, y    
${ONER}^{i}$: son los ocupantes de viviendas particulares en donde no se especificó la disponibilidad de refrigerador.   

**Indicadores simples**  

```{r}
Indicadores <- c(
                 'Porcentaje de población de 15 años o más analfabeta', 
                 'Porcentaje de población de 15 años o más sin educación básica',
                 'Porcentaje de ocupantes en viviendas sin drenaje ni excusado',
                 'Porcentaje de ocupantes en viviendas sin energía eléctrica', 
                 'Porcentaje de ocupantes en viviendas sin agua entubada', 
                 'Porcentaje de viviendas con algún nivel de hacinamiento',
                 'Porcentaje de ocupantes en viviendas con piso de tierra',
                 'Porcentaje de ocupantes en viviendas sin refrigerador'
                 )
```
	




	

	
	
 




<!--chapter:end:01-Indicadores.Rmd-->

```{r include=FALSE, cache=FALSE}
# example R options set globally
options(width = 80)

# example chunk options set globally
knitr::opts_chunk$set(
  comment = "#>",
  collapse = TRUE,
  message = FALSE,
  warning = FALSE
  )
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
setwd(here::here())

```
# Base de datos {.unlisted .unnumbered}


Se define un vector llamado `tablas` que contiene los años `2010` y `2020` como cadenas de texto. Este vector se utilizará para iterar y cargar las bases de datos correspondientes a esos años. 

**Definición de tablas**   


```{r}
tablas <- c("2010", "2020")
```


**Se carga la base de datos para los 3 años**  

 Dentro del iterador `for()`, para cada año se construye el nombre del archivo de datos:    

- Obtención de la tabla: `get(paste0("tabla_",i))` obtiene la tabla cargada previamente (donde el nombre de cada tabla cargada es `tabla_2010`, `tabla_2020`, etc.).    
- Renombrando de la columna: `rename("ANIO" = "AÑO")` cambia el nombre de la columna AÑO a `ANIO`.   
- Filtrado de datos: `filter(NOM_ENT != "Nacional")` elimina las filas donde la columna `NOM_ENT` tiene el valor "Nacional".    
- Conversión de la columna a factor: `dplyr::mutate(ANIO = as.factor(.$ANIO))` convierte la columna `ANIO` en un factor.  


```{r}
for(i in tablas){
load(file = paste0(here::here(), "/Bases/IML_", i, ".RData")) 
}

##Se cambia el nombre de la columna año, para evitar problemas de puntuación
## Se cambia la variable año a factor
for(i in tablas){
assign(paste0("tabla_", i), get(paste0("tabla_", i)) %>% 
                             rename("ANIO" = "AÑO") %>%
                              filter(NOM_ENT != "Nacional") %>%
                               dplyr::mutate(ANIO = as.factor(.$ANIO)))
}
```

<div style="height:700px;overflow:auto;">
```{r, echo = FALSE}
require(gt)
tabla_2020 %>% 
 rename("AÑO" = "ANIO") %>%
  slice(1:25) %>%
    gt() %>%
     tab_header(title = "Indicadores simples de marginación",
                 subtitle = "2020") %>%
      fmt_number(columns = names(tabla_2020)[10:17], 
                  decimals = 2) %>%
       fmt_integer(columns = "POB_TOT", 
                    sep_mark = " ") %>%
        tab_options(heading.title.font.size = 12, 
                    heading.subtitle.font.size = 10,
                    table.font.names = 'Century Gothic',
                    table.font.size = 8,
                    data_row.padding = px(1)) %>%
         tab_style(style = list(cell_text(align = "left",
                                           weight = 'bold')),
                    locations = list(cells_title(groups = c("title")))) %>%
          tab_style(style = list(cell_text(align = "left")),
                     locations = list(cells_title(groups = c("subtitle")))) %>%
           cols_label(CVE_LOC = md("**CVE_LOC**"),
                      ENT = md("**ENT**"),
                      NOM_ENT = md("**NOM_ENT**"), 
                      MUN = md("**MUN**"), 
                      NOM_MUN = md("**NOM_MUN**"),
                      LOC = md("**LOC**"), 
                      NOM_LOC = md("**NOM_LOC**"), 
                      POB_TOT = md("**POB_TOT**"), 
                      AÑO = md("**AÑO**"), 
                      ANALF = md("**ANALF**"),
                      SBASC = md("**SBASC**"),
                      OVSDE = md("**OVSDE**"),
                      OVSEE = md("**OVSEE**"),
                      OVSAE = md("**OVSAE**"),
                      OVPT= md("**OVPT**"),
                      OVHAC = md("**OVHAC**"),
                      OVSREF = md("**OVSREF**")) %>%
         cols_width(starts_with("POB") ~ px(80), 
                    starts_with("NOM") ~ px(150), 
                    everything() ~ px(60)) %>%
            as_raw_html() 
```
</div>

<!--chapter:end:02-Datos.Rmd-->

```{r include=FALSE, cache=FALSE}
# example R options set globally
options(width = 80)

# example chunk options set globally
knitr::opts_chunk$set(
  comment = "#>",
  collapse = TRUE,
  message = FALSE,
  warning = FALSE
  )
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
setwd(here::here())

```
# Análisis de correlaciones  {.unlisted .unnumbered}

La función `corrplot` en `R` es utilizada para crear matrices de correlación visualmente atractivas y fáciles de interpretar. Esta función es parte del paquete `corrplot`, que proporciona herramientas para visualizar y analizar matrices de correlación.   

La matriz de correlación es una tabla que muestra las correlaciones entre pares de variables. En análisis de datos, la correlación se utiliza para medir la relación entre dos variables. Puede ser útil para comprender cómo se relacionan diferentes variables entre sí y cómo afectan a otras variables en un conjunto de datos.   
 
```{r, fig.align='center', fig.width=12, fig.height=12, out.width='100%'}
col2 <- colorRampPalette(c("#67001F", "#B2182B", "#D6604D", "#F4A582", "#FDDBC7", "#FFFFFF", "#D1E5F0", "#92C5DE","#4393C3", "#2166AC", "#053061"))
par(mfrow = c(1,2), family = "Century Gothic", mar = c(0.5, 0, 0, 0), cex.main = 3, col.main = "#053061")
#Análisis de correlaciones
p <- lapply(1:2, function(i){ 
                  x <- cor(get(paste0("tabla_",tablas[i]))[,10:17]) 
                  corrplot(x,
                           title = paste(tablas[i]),
                            type = "upper",
                             method = "color",
                              col = col2(100),
                               tl.col = "blue4",
                                tl.offset = 0.1,
                                 tl.cex = 3,
                                  tl.srt = 90,
                                   cl.align.text = "c",
                                    number.cex = 2,
                                     cl.cex = 2.5,
                                      addCoef.col = "white", # Add coefficient of correlation
                                       mar = c(20, 0, 2.5, 0))
}
)
```





<!--chapter:end:03-Correlaciones.Rmd-->

```{r include=FALSE, cache=FALSE}
# example R options set globally
options(width = 80)

# example chunk options set globally
knitr::opts_chunk$set(
  comment = "#>",
  collapse = TRUE,
  message = FALSE,
  warning = FALSE
  )
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
setwd(here::here())

```
# Método de Distancias $DP2$  {.unlisted .unnumbered}


José Bernardo Pena Trapero: `Problemas de la medición del bienestar y conceptos afines (1977)` 

Los métodos de distancias son enfoques utilizados para medir el bienestar o la calidad de vida de las personas a través de la comparación de diferentes dimensiones o indicadores. Estos métodos se basan en la idea de que el bienestar se puede evaluar considerando la distancia o diferencia entre los individuos en términos de ciertos atributos o variables relevantes.   
La Distancia $DP_{2}$, es un indicador sintético, definido por el profesor `J. Bernardo Pena Trapero`, basado en el concepto de distancia, construido, como su nombre indica para medir distancias entre unidades geográficas, o bien, también se puede aplicar a comparaciones tanto cronológicas como interespaciales.     
   

**Definición**

Sean:   

$\:\:\circ\:r$, el número de municipios;  
$\:\:\circ\:n$, el número de variables;  
$\:\:\circ\:x_{ij}$, el valor de la variable j en el municipio $i$;  
$\:\:\circ\:\sigma_{j}$, La Desviación Típica de la variable $j$;   
$\:\:\circ\:R^{2}_{i,i-1,...,1}$ el Coeficiente de Determinación en la Regresión de $X_{i}$ sobre $X_{i-1},X_{i-2},...,X_{1}$. 

Se define la $Distancia-P_{2}$ de la forma:    

\begin{align}
DP_{2}=\sum^{n}_{i=1}\frac{d_{i}}{\sigma_{i}}(1-R^{2}_{i,i-1,...,1})\:\:;\;\;con \:\:R^{2}_{1}=0
\end{align}

Donde:     

$\:\:\circ\:d_{i} = d_{i}(r,*) = |x_{ri}-x_{*i}|$ |: es la distancia de la j-ésima variable del municipio $r$ con respecto a la base de referencia $x_{*}=(x_{*1}, x_{*2},..., x_{*n})$. Tomando como punto de referencia el valor mínimo de la variable, siendo esta la peor situación teórica,      

 $\:\:\circ\:\sigma_{i}$ : es la desviación estándar de la variable $𝑗$,     
 
 $\:\:\circ\:R^{2}_{i,i-1,...,1}$: es el coeficiente de determinación de la regresión del indicador parcial $𝑗$ con respecto a los otros indicadores $(𝑗−1,𝑗−2,…,1)$. Esta expresión es parte de la varianza del indicador parcial $I_{j}$ que se explica linealmente por el resto de los indicadores parciales,        

$\:\:\circ\:(1-R^{2}_{i,i-1,...,1})$): es el factor corrector que evita la duplicidad, al eliminar la información parcial de los indicadores ya contenidos en los indicadores precedentes, y     

$\:\:\circ\:R^{2}_{1}=0$; porque la primera componente aporta toda la información y al no existir un componente previo su ponderación es la unidad.  

El $DP_{2}$ cumple con las siguientes propiedades: no negatividad, homogeneidad, conmutatividad, desigualdad triangular, existencia y determinación, monotonía, unicidad, transitividad, no duplicidad de información, invariancia al cambio de origen y/o de escala en las unidades y exhaustividad.      


El orden de entrada de las variables   

```{r}
# Se multiplica por -1, debido a que son indicadores de carencia 
for(i in tablas){	
  assign(paste0("DP2_datos_", i), (-1 * get(paste0("tabla_", i))[10:17]))
}
```

Para asegurar las propiedades del indicador sintético, un aumento en los indicadores simples implica un aumento en la carencia de los servicios, lo que implicaría una disminución de la calidad de vida, por lo que se multiplica cada indicador por **-1**, de esta forma, un aumento en la variable supone una mejora en la calidad de vida.    


## Base de referencia  {-}

Se define al valor de referencia para cada uno de los indicadores parciales, con la finalidad de hacer comparaciones entre las diferentes unidades espaciales (Localidades). Siendo este el valor mínimo de cada indicador simple como referencia, representado como la “situación no deseada”. Como resultado, un valor alto implicaría una distancia alejada con respecto a una situación teórica “situación no deseada”. Por lo tanto $d_{ij}$ mide la distancia entre el indicador parcial $j$ en la entidad $i$ y su valor de referencia.    

Se toma como base de referencia el valor del mínimo del `2010 - 2020`, ya que este tipo de cambio permite la comparabilidad en el tiempo.    


```{r}
#Base de referencia 2010 - 2020
for(i in tablas){
assign(paste0("minRV_", i), setNames(c(-100, # ANALF
                                       -100, # SBASC
                                       -100, # OVSDE
                                       -100, # OVSEE
                                       -100, # OVSAE
                                       -100, # OVPT
                                       -100, # OVHAC
                                       -100), # OVSREF
                              nm = c("ANALF", "SBASC", "OVSDE", "OVSEE", "OVSAE", "OVPT", "OVHAC", "OVSREF")))
}
```


```{r, echo = FALSE}
minRV <- minRV_2010 %>%
          t() %>%
           as.data.frame() %>%
            tibble::rownames_to_column(.data = .) %>%
             dplyr::mutate(rowname = case_when(rowname %in% 1 ~ "2010 - 2020")) %>%
              rename("ANIO" = "rowname")

minRV %>% 
  rename("AÑO" = "ANIO") %>%
   gt() %>%
    tab_header(title = "Base de referencia") %>%
     fmt_number(columns = names(tabla_2020)[10:17], 
                decimals = 2) %>%
      tab_options(heading.title.font.size = 14, 
                  heading.align = "center",
                  heading.subtitle.font.size = 12,
                  table.align = "center",
                  table.font.names = 'Century Gothic',
                  table.font.size = 10) %>%
       tab_style(style = list(cell_text(align = "center",
                                         weight = 'bold')),
                  locations = list(cells_title(groups = c("title")))) %>%
        tab_style(style = list(cell_text(align = "left")),
                   locations = list(cells_title(groups = c("subtitle")))) %>%
         cols_label(AÑO = md("**AÑO**"), 
                    ANALF = md("**ANALF**"),
                    SBASC = md("**SBASC**"),
                    OVSDE = md("**OVSDE**"),
                    OVSEE = md("**OVSEE**"),
                    OVSAE = md("**OVSAE**"),
                    OVPT= md("**OVPT**"),
                    OVHAC = md("**OVHAC**"),
                    OVSREF = md("**OVSREF**")) %>%
          as_raw_html() 
```



## Método de Distancia $DP_{2}$  {-}   

```{r, results=FALSE}
require(p2distance)
##Calculo del Método de Distancias DP2
for(i in tablas){
assign(paste0("ind_", i), p2distance(matriz = as.matrix(get(paste0("DP2_datos_", i))), 
                                      reference_vector = get(paste0("minRV_", i)), 
                                       iterations = 50))
}
```

**Total de iteraciones** 

```{r, collapse=TRUE}
iteration <- lapply(1:2, function(x) get(paste0("ind_", tablas[x]))[["iteration"]])
```


```{r, echo=FALSE}
tabla <- do.call(rbind, iteration) %>%
                  as.data.frame() %>%
                   tibble::rownames_to_column(.data = .) %>%
                    dplyr::mutate(rowname = case_when(rowname %in% 1 ~ "2010",
                                                      rowname %in% 2 ~ "2020")) %>%
                     rename("ANIO" = "rowname")

tabla %>% 
 rename("AÑO" = "ANIO") %>%
  gt() %>%
   tab_header(title = "Número de iteraciones") %>%
    fmt_integer(columns = "V1") %>%
     tab_options(heading.title.font.size = 12, 
                 heading.subtitle.font.size = 10,
                 table.font.names = 'Century Gothic',
                 table.align = "center",
                 table.font.size = 8,
                 data_row.padding = px(1)) %>%
      tab_style(style = list(cell_text(align = "left",
                                        weight = 'bold')),
                 locations = list(cells_title(groups = c("title")))) %>%
       tab_style(style = list(cell_text(align = "left")),
                  locations = list(cells_title(groups = c("subtitle")))) %>%
        cols_label(AÑO = md("**AÑO**"), 
                    V1 = md("**Iteraciones**")) %>%
         as_raw_html() 
```




Se anexan los resultados a las bases de datos original

```{r}
for(i in tablas){
assign(paste0("DP2_", i), cbind(get(paste0("tabla_", i)), get(paste0("ind_", i))[["p2distance"]]))
}

# Se cambian los nombres de las columnas 
for(i in 1:2){
  columns = get(paste0("DP2_", tablas[i]))
  colnames(columns) = c("CVE_LOC", "ENT", "NOM_ENT", "MUN", "NOM_MUN", "LOC", "NOM_LOC", "POB_TOT", "ANIO",
                        "ANALF", "SBASC", "OVSDE", "OVSEE", "OVSAE", "OVPT", "OVHAC", "OVSREF",
                        paste0("IM_", tablas[i]))
  assign(paste0("DP2_", tablas[i]), columns)
  rm(columns)
}
```

<!--chapter:end:04-Distancias.Rmd-->

```{r include=FALSE, cache=FALSE}
# example R options set globally
options(width = 80)

# example chunk options set globally
knitr::opts_chunk$set(
  comment = "#>",
  collapse = TRUE,
  message = FALSE,
  warning = FALSE
  )
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
setwd(here::here())

```
# Método de estratificación  {.unlisted .unnumbered}

### Identificación de datos atípicos {-}   

Para hacer cumplir la definición de los límites en el método de estratificación [véase: `Método de estratificación de Dalenius & Hodges`] y el número óptimo de clases basados en la media aritmética, es importante la identificación de datos atípicos porque podrían ocasionar resultados poco adecuados. Para contrarrestar este problema, `Hubert y Vandervieren (2007)` proponen el método de caja, el cual toma en cuenta el grado de asimetría de un conjunto de datos.  

$$\left[Q_{1} - 1.5e^{-4MC} IQR; \hspace{0.5cm}  Q_{3} + 1.5e^{-4MC} IQR \right] \text{para } MC \geq 0$$
$$\left[Q_{1} - 1.5e^{-3MC} IQR; \hspace{0.5cm}  Q_{3} + 1.5e^{-3MC} IQR \right] \text{para } MC < 0$$
donde:   
$\circ \:𝑄_{1}$ 𝑦 $𝑄_{3}$: hacen referencia al primer y tercer cuartil, respectivamente; la diferencia entre estos dos valores da como resultado el valor de espacio intercuartil ($𝐼𝑄𝑅$), y    
$\circ \:𝑀𝐶 (𝑚𝑒𝑑𝑐𝑜𝑢𝑝𝑙𝑒)$: cuantifica el grado de asimetría de una muestra univariable ${𝑥_1,𝑥_2,… ,𝑥_𝑛}$.     

Se identifican los valores atípicos para cada conjunto de datos para cada año. 

- Se itera sobre cada elemento de la lista `tablas` que corresponden a los años `2010` y `2020`. 
- Se calculan los estadísticos de la columna del índice de marginación para cada conjunto de datos $DP2_{i}$ correspondientes al año y se asigna el resultado a una nueva variable denominada $outliers_i$.    

```{r}
for(i in tablas){
  assign(paste0("outliers_", i), boxplot.stats(get(paste0("DP2_", i))[,18]))
}
```

Se crea un data.frame que contiene el número de valores atípicos, su rango y el límite inferior para cada conjunto de datos.   

```{r, echo = FALSE}
#Límites para el cálculo de estratificación a nivel localidad, 2010 - 2020
p <- NULL
for(i in tablas){
p[[paste0(i)]] <- data.frame(n = length(get(paste0("outliers_", i))$out), 
                             rango = range(get(paste0("outliers_", i))$out), 
                             lim = get(paste0("outliers_", i))$stats[1])
}
```

```{r, echo = FALSE}
tabla <- data.frame(outliers = p[["2010"]][["n"]][1],
                    minimo = p[["2010"]][["rango"]][1],
                    maximo = p[["2010"]][["rango"]][2])   
tabla %>% 
 gt() %>%
   tab_header(title = "Límites para el cálculo de estratificación a nivel localidad, 2010") %>%
    fmt_number(columns = c(2:3), decimals = 3) %>%
    tab_options(heading.title.font.size = 14, 
                heading.subtitle.font.size = 12,
                table.font.names = 'Century Gothic',
                table.align = "center",
                table.font.size = 10,
                data_row.padding = px(1)) %>%
    tab_style(style = list(cell_text(align = "left",
                                      weight = 'bold')),
               locations = list(cells_title(groups = c("title")))) %>%
     tab_style(style = list(cell_text(align = "left")),
                locations = list(cells_title(groups = c("subtitle")))) %>%  
      cols_label(outliers = md("**Valores atípicos**"), 
                minimo = md("**Mínimo**"),
                maximo = md("**Límite**")) %>%
       tab_spanner(label = "Rango",
                   columns = c(minimo, maximo)) %>%
         as_raw_html() 
```

```{r, echo = FALSE}
tabla <- data.frame(outliers = p[["2020"]][["n"]][1],
                    minimo = p[["2020"]][["rango"]][1],
                    maximo = p[["2020"]][["rango"]][2])   
tabla %>% 
 gt() %>%
   tab_header(title = "Límites para el cálculo de estratificación a nivel localidad, 2020") %>%
    fmt_number(columns = c(2:3), decimals = 3) %>%
    tab_options(heading.title.font.size = 14, 
                heading.subtitle.font.size = 12,
                table.font.names = 'Century Gothic',
                table.align = "center",
                table.font.size = 10,
                data_row.padding = px(1)) %>%
    tab_style(style = list(cell_text(align = "left",
                                      weight = 'bold')),
               locations = list(cells_title(groups = c("title")))) %>%
     tab_style(style = list(cell_text(align = "left")),
                locations = list(cells_title(groups = c("subtitle")))) %>%  
      cols_label(outliers = md("**Valores atípicos**"), 
                minimo = md("**Mínimo**"),
                maximo = md("**Límite**")) %>%
       tab_spanner(label = "Rango",
                   columns = c(minimo, maximo)) %>%
         as_raw_html() 
```



Se identifican los casos extremos en el índice de marginación y se aplica el método de caja propuesto por `Hubert y Vandervieren`, concluyendo los límites con los que se debe trabajar.      

Se añade una nueva columna `IM_out`. Esta columna se calcula usando `if_else`, de la siguiente manera:   

- Si el valor de IM es mayor o igual al límite inferior de los valores no considerados outliers `(get(paste0("outliers_", i))$stats[1])`, entonces `IM_out` toma el valor de `IM`.   
- Si el valor de IM es menor que el límite inferior, entonces `IM_out` toma el valor del límite inferior, eliminando así los outliers.      

```{r}
## Se crea un índice ficticio, en la que se quitan los outliers   
for(i in tablas){
assign(paste0("DP2_", i), get(paste0("DP2_", i)) %>% 
                            mutate(IM = get(paste0("IM_", i))) %>%
                             mutate(IM_out = if_else(.$IM >= get(paste0("outliers_", i))$stats[1],
                                                      .$IM,
                                                        get(paste0("outliers_", i))$stats[1])) %>%
                              select(-paste0("IM_", i))
  )
}
```


### Método de estratificación de Dalenius & Hodges {-}

`strata.cumrootf`: cumulative root frequency method by Dalenius and Hodges (1959). 

Con la obtención del índice de marginación a través del método DP2, los valores se clasificaron en cinco categorías ordinales con el método de Dalenius y Hodges (1959), para obtener el grado de marginación. Este método forma estratos de manera que la varianza sea mínima al interior de cada estrato y máxima entre cada uno de ellos, es decir, son lo más homogéneos posibles. Este procedimiento utiliza la raíz de las frecuencias acumuladas para la construcción de los estratos, por lo que se lleva a cabo para la división de la población en el estrato L. Esta es una solución aproximada de Dalenius y Hodges (1959) a las ecuaciones de Dalenius (1950). De acuerdo con Gunning y Horgan (2004), el límite superior de cada estrato se determinó con la siguiente expresión:  

$$Q = \frac{1}{L}\sum^{J}_{i=1}{\sqrt{f_{i}}}$$

Sea un conjunto de estratos determinados por su límite superior,

 $$Q,\ 2Q,\ \ldots,\ \left(L-1\right)Q,\ (L)Q.$$
donde:  

$\circ \:J$: es el número de clases dentro del grupo de la variable ordenada X,    
$\circ \:f_{i}\ \in(1,\ \ldots, J)$: es la frecuencia en cada clase  $J$, y  
$\circ \:L$: es el número de estratos.   


La eficiencia del método de la raíz de las frecuencias acumuladas depende principalmente del número de clases dentro del grupo de la variable ordenada. Sin embargo, no hay un procedimiento estándar sobre cómo elegir el mejor valor para el número de clases, siendo esto una limitante del método de Dalenius y Hodges. Para medir el efecto del número  de clases en la varianza de cada estrato se recurrió a un método iterativo para obtener un criterio de agrupación óptimo.    

Para establecer los límites de los estratos $(b_{1},\ \ldots,\ b_{L})$ que minimicen la varianza del estimador, se utiliza la asignación de Neyman para determinar el tamaño de muestra óptimo. Sea la varianza del estimador:    

$$V\left({\bar{x}}_{st}\right)=\ \sum_{h}\left(\frac{N_h}{N}\right)^2\frac{S_h^2}{n_h}\ $$
donde:

$\circ  \: S_{h}^{2}$: es la varianza poblacional en el estrato $h$,   
$\circ  \:n_{h}$: es el tamaño de muestra en el estrato $h$ utilizada por la asignación de Neyman, y 
$\circ  \:N_{h}$: es el total de elementos en el estrato $h$, sea $N=\sum_{h=1}^{L}{N_{h}}$.     

Si se asume que la distribución dentro de cada estrato se distribuye aproximadamente de manera uniforme, los límites se obtienen tomando intervalos iguales en la función de la raíz de las frecuencias acumuladas. Los límites se resuelven de manera iterativa:   

$$\frac{S_h^2+(b_h-{\bar{X}}_h)2}{S_h}=\frac{S_{h+1}^2+(b_h-{\bar{X}}_{h+1})2}{S_{h+1}}\ para\ h=1,\ \ldots.\ ,\ L-1$$
donde:

$\circ  \: b_{h}$: es el límite superior en el estrato $h$,   
$\circ  \: {\bar{X}}_{h}$: es la media poblacional en el estrato $h$, y   
$\circ  \: S_{h}^{2}$: es la varianza poblacional en el estrato $h$.      

El requisito de precisión, generalmente se establece cuando el coeficiente de variación sea igual a un nivel especificado entre 1 y 10 por ciento (Hidiroglou y Kozak, 2018).     

## Número óptimo de clases del método de Dalenius & Hodge {-}  

`alloc` lista que especifica el esquema de asignación. La lista debe contener 3 números para los 3 exponentes q1, q2 y q3 en el esquema de asignación general (ver paquete de `stratification`). El valor predeterminado es la asignación de **Neyman** (q1 = q3 = 0.5 y q2 = 0)   

A continuación, se realiza un análisis de estratificación sobre los diferentes años, usando la función `strata.cumrootf()`, almacenando los resultados de errores estándar, medias y varianzas en matrices que luego se guardan en listas.    

```{r, results=FALSE, warning=FALSE, eval = FALSE}
iteraciones <- 1000
start.time <- Sys.time()
DH_Localidad <- list()
stderr <- list()
mean <- list()
var <- list()
for(j in 1:2){
i <- 1
  sd <- matrix(NA, nrow = (iteraciones), ncol = 3)
  meanh <- matrix(NA, nrow = (iteraciones), ncol = 6)
  varh <- matrix(NA, nrow = (iteraciones), ncol = 6)
 for(n in seq(5, (iteraciones), 1)){
      DH_Localidad[[paste(tablas[j])]][[n]] <- strata.cumrootf(x = get(paste0("DP2_", tablas[j]))[,19], CV = 0.05, Ls = 5, alloc = c(0.5, 0, 0.5), nclass = n)
      cum <- DH_Localidad[[paste(tablas[j])]][[n]]
      sd[i,] <-  c(n, cum$stderr, cum$CV)
      meanh[i,] <- c(n, cum$meanh)
      varh[i,] <-  c(n, cum$varh)
      i <- i + 1
}
  stderr[[j]] <- sd
  mean[[j]] <- meanh
  var[[j]] <- varh
}

for(i in 1:2){
  colnames(stderr[[i]]) <- c("n", "sderr", "CV")
}

end.time <- Sys.time()
time.taken <- round(end.time - start.time, 2)
time.taken
```


```{r, echo = FALSE}
#saveRDS(stderr, file = paste0(here::here(), "/Output/stderr.RDS"))
stderr <- readRDS(file = paste0(here::here(), "/Output/stderr.RDS"))
```



#### Número óptimo de clases {-} 

Se toma cada matriz resultante de errores estándar de la lista `stderr`, y luego selecciona la fila que tiene el coeficiente de variación (`CV`) más bajo. Estos resultados se almacenan en la lista `min.strata`, la cual contendrá los data.frames correspondientes a las filas con el menor `CV `para cada uno de los tres conjuntos de datos en `stderr`.


```{r}
min.strata <- NULL
for(i in 1:2){
  min.strata[[i]] <- stderr[[i]] %>%
                      as.data.frame() %>% 
                       slice(which.min(.$CV))
}
```

```{r, echo = FALSE}
tabla <- do.call(rbind.data.frame, min.strata) %>%
          dplyr::mutate(ANIO = tablas) %>%
           relocate(ANIO, .before = "n")

tabla %>% 
 rename("AÑO" = "ANIO") %>%
  gt() %>%
   tab_header(title = "Número óptimo de clases") %>%
    fmt_integer(columns = names(tabla)[2]) %>%
     fmt_number(columns = names(tabla)[3:4],
                decimals = 2) %>%
       tab_options(heading.title.font.size = 14, 
                   heading.subtitle.font.size = 12,
                   table.font.names = 'Century Gothic',
                   table.align = "center",
                   table.font.size = 10) %>%
        tab_style(style = list(cell_text(align = "left",
                                          weight = 'bold')),
                   locations = list(cells_title(groups = c("title")))) %>%
         tab_style(style = list(cell_text(align = "left")),
                    locations = list(cells_title(groups = c("subtitle")))) %>%
          cols_label(AÑO = md("**AÑO**"),
                     n = md("**n**"),
                     sderr = md("**sd**"),
                     CV = md("**C.V.**")) %>%
           as_raw_html() 
```



```{r, echo = FALSE, results=FALSE, out.width='80%'}
p <- NULL
for(i in 1:2) {
p[[i]] <- stderr[[i]] %>%
           as.data.frame() %>%
            arrange(desc(.$CV)) %>%
             mutate(count = seq(1, nrow(stderr[[i]]))) %>%
              ggplot() + 
               geom_point(aes(x = count, y = CV)) + 
                geom_line(aes(x = count, y = CV)) +
                 geom_text(data = min.strata[[i]], aes(label = paste0("CV = ", round(CV, 4)), x = iteraciones - 75, y = CV), 
                           vjust = -1,
                            size = 6,
                             color = "red",
                              family = "Century Gothic") +
                  geom_hline(data = min.strata[[i]], aes(yintercept = CV), color = "red") +
                   theme_minimal() + 
                    theme(title = element_text(family = "Century Gothic"), 
                          plot.title = element_text(size = 22, family = "Century Gothic"),
                          plot.subtitle = element_text(size = 20, family = "Century Gothic"),
                          axis.text = element_text(size = 14, family = "Century Gothic"),
                          axis.title = element_text(size = 18, family = "Century Gothic")) + 
                     scale_y_continuous(labels = scales::number_format(accuracy = 0.01)) +
                 labs(title = "Coeficiente de variación óptimo",
                       subtitle = paste(tablas[i]),
                        y = "CV", 
                         x = "iteraciones") 
}
```

<a href="https://raw.githubusercontent.com/dvillasanao/IML_2010-2020/main/img/iteraciones.png" data-lightbox="image-1" data-title="iteraciones">
```{r, echo = FALSE, fig.width=12, fig.height=12, out.width='100%'}
knitr::include_graphics(paste0(here::here(), "/img/iteraciones.png"))
```


Se toman en cuenta el número de clases que salen del los resultados del método iterativo. Utilizando la función `strata.cumrootf()` de la paquetería `stratification` con parámetros específicos y el número de clases (`nclass`) obtenido de `min.strata`.       
- `CV = 0.05`: Establece el coeficiente de variación.   
- `Ls = 5`: Establece el número de estratos.   
- `alloc = c(0.5, 0, 0.5)`: Define la asignación para la estratificación.    
- `nclass = min.strata[[i]][,1]`: Establece el número de clases utilizando el primer valor de la fila con el menor CV en `min.strata`.   

```{r}
for(i in 1:2){
  assign(paste0("strata.DP2_", tablas[i]), strata.cumrootf(get(paste0("DP2_", tablas[i]))[,19],
                                                            CV = 0.05,
                                                             Ls = 5,
                                                              alloc = c(0.5, 0, 0.5), 
                                                               nclass = min.strata[[i]][,1]))
}
```

Se agregan los datos a la base original.  

```{r}
##Se agrega a la base DP2
for(i in 1:2){
  assign(paste0("DP2_", tablas[i]), data.frame(get(paste0("DP2_", tablas[i])) %>% 
                                                select(-IM_out),   # Se quita el índice ficticio
                                                 get(paste0("strata.DP2_", tablas[i]))[["stratumID"]]))
}

# Se cambian los nombres de las columnas 
for(i in 1:2){
  columns = get(paste0("DP2_", tablas[i]))
  colnames(columns) = c("CVE_LOC", "ENT", "NOM_ENT", "MUN", "NOM_MUN", "LOC", "NOM_LOC", "POB_TOT", "ANIO",
                        "ANALF", "SBASC", "OVSDE", "OVSEE", "OVSAE", "OVPT", "OVHAC", "OVSREF",
                        paste0("IM_", tablas[i]), paste0("GM_", tablas[i]))
  assign(paste0("DP2_", tablas[i]), columns)
  rm(columns)
}

# Se cambian los levels a los grados de marginación correspondientes
for(i in tablas){
  niveles = get(paste0("DP2_", i)) 
  levels(niveles[,19]) = c("Muy alto", "Alto", "Medio", "Bajo", "Muy bajo")
  assign(paste0("DP2_", i), niveles)
}
```


### Límites de los estratos {-}

Se crea un data frame llamado `limites` que contiene los límites de ciertos intervalos para los años `2010` y `2020`. Cada columna contiene una combinación de:   
- El valor mínimo del índice de marginación (`IM:`) para el año correspondiente.  
- Los valores de los límites de los estratos (`bh`) calculados previamente.  
- El valor máximo del índice de marginación (`IM_`) para el año correspondiente.      

```{r}
limites <- data.frame("2010" = c(min(DP2_2010$IM_2010), strata.DP2_2010$bh, max(DP2_2010$IM_2010)),
                      "2020" = c(min(DP2_2020$IM_2020), strata.DP2_2020$bh, max(DP2_2020$IM_2020)))
```


```{r, echo = FALSE}
tabla <- limites %>%
          t()  %>%
           as.data.frame() %>%
            mutate_if(is.numeric, round, digits = 2) %>%
             tibble::rownames_to_column(.data = .) %>% 
              mutate(ANIO = c("2010", "2020"),
                     `Muy alto` = paste("[", V1, "-", V2, "]"),
                     `Alto` = paste("(", V2, "-", V3, "]"),
                     `Medio` = paste("(", V3, "-", V4, "]"),
                     `Bajo` = paste("(", V4, "-", V5, "]"),
                     `Muy bajo` = paste("(", V5, "-", V6, "]")) %>%
               select(., c(8:13))

tabla %>% 
 rename("AÑO" = "ANIO") %>%
  gt(rowname_col = c("AÑO")) %>%
   tab_header(title = "Límite de los estratos") %>%
    tab_options(heading.title.font.size = 14, 
                heading.align = "center",
                heading.subtitle.font.size = 12,
                table.align = "center",
                table.font.names = 'Century Gothic',
                table.font.size = 10) %>%
     tab_style(style = list(cell_text(align = "center",
                                       weight = 'bold')),
                locations = list(cells_title(groups = c("title")))) %>%
      cols_label(AÑO = md("**AÑO**"), 
                 `Muy alto` = md("**Muy alto**"),
                 `Alto` = md("**Alto**"),
                 `Medio` = md("**Medio**"),
                 `Bajo` = md("**Bajo**"),
                 `Muy bajo` = md("**Muy bajo**")) %>%
      as_raw_html() 
```



<!--chapter:end:05-Estratificacion.Rmd-->

```{r include=FALSE, cache=FALSE}
# example R options set globally
options(width = 80)

# example chunk options set globally
knitr::opts_chunk$set(
  comment = "#>",
  collapse = TRUE,
  message = FALSE,
  warning = FALSE
  )
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
setwd(here::here())

```
# Índice normalizado  {.unlisted .unnumbered}

Otra forma de apreciar el índice de marginación es normalizando sus valores para ver objetivamente la evolución de cada unidad territorial (Somarriba et al. 2013). La normalización se realiza utilizando un cambio de escala conocido como normalización mínima-máxima. Con este procedimiento el índice de marginación se escala a valores relativos con un rango de entre cero y uno, lo cual permite su comparación numérica y le da una propiedad adicional al índice de marginación. Al mismo tiempo, la normalización determina el mismo sentido que el índice obtenido por el método DP2, donde los valores cercanos a cero implican mayor marginación.  

El proceso de normalización consiste en:

$${DP}_2normalizado=\frac{{DP}_2^i-\min({DP}_2)}{\max({DP}_2)-\min({DP}_2)},$$
donde:

$\circ \: {DP}_{2}^{i}$: es el valor del índice de marginación de la localidad $i$,   
$\circ \: min ({DP}_{2})$: es el valor mínimo o peor escenario que puede tomar el índice, y   
$\circ \: max ({DP}_{2})$: es el valor máximo u objetivo que puede tomar el índice.  


## Desviación estándar de los indicadores simples  {-}

**Varianza muestral insesgada**    
**Estimado insesgado de la varianza poblacional**      

$$s^{2} = \frac{1}{n-1}\left(x_{i}-\bar{x}\right)^{2} = \frac{\sum_{i=1}^{n}(x_{i}^{2})}{n-1} - \frac{\sum_{i=1}^{n}(x_{i})^{2}}{(n-1)\: n } = \left(\frac{n-1}{n}\right)s_{n}^{2} $$
Se calcula la desviación estándar muestral y su inversa para un conjunto de indicadores simples. Para cada elemento:   
- Extrae las columnas 10 a 17 del data frame correspondiente (`DP2_`).  
- Calcula la desviación estándar para cada una de estas columnas.  
- Ajusta la desviación estándar para obtener la desviación estándar muestral.  
- Calcula la inversa de la desviación estándar muestral.  
- Almacena los resultados en un data frame dentro de la lista `desvest`.     

```{r}
# Desviación estándar de los indicadores
desvest <- NULL
for(i in 1:2){
desvest[[i]] <- as.matrix(apply(get(paste0("DP2_", tablas[i]))[10:17], MARGIN = 2, sd)) %>%
                 as.data.frame() %>%
                  rename("desvest" = "V1") %>%
                   dplyr::mutate(sd_muestral = .$desvest * (sqrt((dim(get(paste0("DP2_", tablas[i]))[10:17])[1] - 1)/dim(get(paste0("DP2_", tablas[i]))[10:17])[1]))) %>%
                    dplyr::mutate(desvest.inversa = 1/(.$sd_muestral))
}
```


```{r, echo = FALSE}
# Tabla
tabla <- desvest[[2]] %>%
          tibble::rownames_to_column()

tabla %>%
 gt() %>%
  tab_header(title = "Desviación estándar") %>% 
   tab_options(heading.title.font.size = 14, 
               heading.align = "center",
               heading.padding = 5,
               heading.subtitle.font.size = 12,
               table.align = "center",
               table.font.names = 'Century Gothic',
               table.font.size = 10,
               data_row.padding = px(1)) %>%
    tab_style(style = list(cell_text(align = "center",
                                      weight = 'bold')),
               locations = list(cells_title(groups = c("title")))) %>%
     cols_label(`desvest` = md("**Desviación estándar**"), 
                `sd_muestral` = md("**Desviación estándar muestral**"),
                `desvest.inversa` = md("**Desviación estandar m. inversa**")) %>%
      fmt_number(columns = c(1:4), decimals = 3) %>%
      as_raw_html()
```

## Escenarios extremos {-}

Para este tipo de cálculo es necesario conocer los puntos más extremos que puede tomar el índice en el año de observación. De antemano, se sabe que cada indicador simple toma valores de cero a 100 y, además, el método DP2 ya proporcionó el orden de entrada de las variables. Usando estos criterios se estiman los puntos focales extremos que puede tomar el índice de marginación. Se sabe que la peor situación es cuando una unidad de análisis toca todos y cada uno de los valores mínimos del vector base de referencia común, esto sería el peor escenario de marginación y tomaría un valor de cero. En sentido contrario, el valor máximo sería la situación con la menor marginación.   

**Escenarios del mínimo y máximo valor en el índice DP2**  

Se calculan los valores mínimo y máximo del índice `DP2` para diferentes escenarios y años. Para cada elemento, se calcula:   
- `Valor mínimo`: Calcula la diferencia absoluta entre minRV_2010 y vector_minimo, ajusta con la inversa de la desviación estándar muestral y los factores de corrección, y suma las filas para obtener el DP2.   
- `Valor máximo`: Calcula la diferencia absoluta entre minRV_2010 y un vector de ceros (vector_maximo), ajusta con la inversa de la desviación estándar muestral y los factores de corrección, y suma las filas para obtener el DP2.    

```{r}
minimo <- NULL
maximo <- NULL
## Mínimo valor del DP2
for(i in 1:2){
vector_minimo <- minRV_2010  
tabla <- abs(vector_minimo - minRV_2010) * desvest[[i]][["desvest.inversa"]] *
          get(paste0("ind_", tablas[i]))[["correction_factors"]][names(DP2_2020[10:17])] %>%
           t() %>%
            as.data.frame() 
minimo[[i]] <- data.frame(AÑO = paste(tablas[i]), Escenario = "Mínimo", tabla, DP2 = rowSums(tabla))
  
## Máximo valor del DP2   
vector_maximo <- rep(0, 8) # Cuando los indicadores valen cero 
tabla <- abs(vector_maximo - minRV_2010) * desvest[[i]][["desvest.inversa"]] *
          get(paste0("ind_", tablas[i]))[["correction_factors"]][names(DP2_2020[10:17])] %>%
           t() %>%
            as.data.frame() 

maximo [[i]] <- data.frame(AÑO = paste(tablas[i]), Escenario = "Máximo", tabla, DP2 = rowSums(tabla))
}
```


## Índice normalizado {-}

**Se guarda la base de datos con el índice normalizado**  

Se calcula un nuevo indicador denominado `IMN para cada año, normalizando el índice DP2 entre sus valores mínimos y máximos. 

```{r}
for(i in 1:2){
min_DP2 <- minimo[[i]][["DP2"]]
max_DP2 <- maximo[[i]][["DP2"]]
assign(paste0("DP2_", tablas[i]), get(paste0("DP2_", tablas[i])) %>%
                                   dplyr::mutate(IMN = (get(paste0("IM_", tablas[i])) - min_DP2)/(max_DP2 -  min_DP2)))
}
```


::: {style="height:700px;overflow:auto;"}
```{r, echo=FALSE}
#Tabla final
DP2_2020 %>% 
 rename("AÑO" = "ANIO") %>%
  slice(1:25) %>%
  gt() %>%
   tab_header(title = "Índice de marginación a nivel localidad, 2020") %>%
    tab_options(heading.title.font.size = 14, 
                heading.align = "center",
                heading.subtitle.font.size = 12,
                table.align = "center",
                column_labels.font.weight = "bold",
                table.font.names = 'Century Gothic',
                table.font.size = 10,
                data_row.padding = px(1)) %>%
     tab_style(style = list(cell_text(align = "center",
                                       weight = 'bold')),
                locations = list(cells_title(groups = c("title")))) %>%
      fmt_integer(columns = "POB_TOT", sep_mark = " ") %>%
       fmt_number(columns = c(10:17), decimals = 1) %>%
        fmt_number(columns = c(18, 20), decimals = 3) %>%
         cols_width(starts_with("POB") ~ px(100), 
                    starts_with("NOM") ~ px(260), 
                    everything() ~ px(60)) %>%
          cols_label(IMN = md("IMN_2020")) %>%
           as_raw_html()
```
:::

 
 
 <\br>
```{r, eval = FALSE}
#Tabla final
for(i in tablas){
save(get(paste0("DP2_", i)), file = paste0(here::here(), "/Output/IML_", i, ".RData"))
}
```


<!--chapter:end:06_Normalizacion.Rmd-->

```{r include=FALSE, cache=FALSE}
# example R options set globally
options(width = 80)

# example chunk options set globally
knitr::opts_chunk$set(
  comment = "#>",
  collapse = TRUE,
  message = FALSE,
  warning = FALSE
  )
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
setwd(here::here())

```
# Validación de datos  {.unlisted .unnumbered}


**Se crea en una lista que contiene el resumen del método `DP2` para todos los años**

```{r}
for(i in tablas){
List_DP2 <- mget(paste0("ind_", tablas))
}
```

## Orden de entrada de las variables  {-}

**Se crea un data.frame de acuerdo al orden de importancia de las variables para todos los años**   
Dependiendo del proceso, el `DP2` adoptará diferentes valores. Por lo tanto, es importante que el método de como resultado un orden de entrada único de los indicadores parciales.   

```{r}
Variables_sort <- NULL
for(i in 1:2){
Variables_sort[i] <- as.data.frame(lapply(List_DP2, function(x) get(paste0("ind_", tablas[i]))$variables_sort))
}

Variables_sort <- do.call(cbind.data.frame, Variables_sort)
colnames(Variables_sort) <- c("2010", "2020")
```

```{r, echo = FALSE}
Variables_sort %>%
 gt() %>%
  tab_header(title = "Variables sort") %>%
   tab_options(heading.title.font.size = 14, 
               heading.align = "center",
               heading.subtitle.font.size = 12,
               table.align = "center",
               table.font.names = 'Century Gothic',
               table.font.size = 10,
               data_row.padding = px(1)) %>%
    tab_style(style = list(cell_text(align = "center",
                                      weight = 'bold')),
               locations = list(cells_title(groups = c("title")))) %>%
     cols_label(`2010` = md("**2010**"), 
                `2020` = md("**2020**")) %>%
      cols_width(everything() ~ px(80)) %>%
      as_raw_html() 
```


## Coeficiente de correlación {-}  

El coeficiente de correlación es una medida que se utiliza para jerarquizar a los indicadores simples de acuerdo con el grado de correlación absoluta con respecto al indicador sintético resultante, es decir, ayuda a visualizar que variable tiene un mejor o peor apego con el fenómeno.     

**Se crea un data.frame de acuerdo a la correlación de cada variable con el indicador sintético (DP2) para todos los años**  

```{r}
cor.coeff <- NULL
cor.coeff <- lapply(1:2, function(i) data.frame(rownames(get(paste0("ind_", tablas[i]))[["cor.coeff"]]),
                                                 get(paste0("ind_", tablas[i]))$cor.coeff))
cor.coeff <- do.call(cbind.data.frame, cor.coeff)
colnames(cor.coeff) <- c("Ind_2010", "2010", "Ind_2020", "2020")
```


```{r, echo = FALSE}
cor.coeff %>%
  gt() %>%
   tab_header(title = "Correlation Coefficient") %>%
    tab_options(heading.title.font.size = 14, 
                heading.align = "center",
                heading.subtitle.font.size = 12,
                table.align = "center",
                table.font.names = 'Century Gothic',
                table.font.size = 10,
                data_row.padding = px(1)) %>%
      tab_style(style = list(cell_text(align = "center",
                                       weight = 'bold')),
                locations = list(cells_title(groups = c("title")))) %>%
       cols_label(`Ind_2010` = md("**Ind**"), 
                  `2010` = md("**2010**"),
                  `Ind_2020` = md("**Ind**"),
                  `2020` = md("**2020**")) %>%
        fmt_number(columns = c(2, 4), decimals = 3) %>%
         cols_width(everything() ~ px(80)) %>%
          as_raw_html()         
```

## Factor de corrector  {-}

El factor corrector, como se mencionó anteriormente, indica la proporción de información con la que contribuye el indicador simple al nuevo índice sintético, además, evita la duplicidad e incorpora información útil que retiene cada indicador simple.     

**Se crea un data.frame de acuerdo al factor corrector de cada indicador parcial para todos los años**

```{r}
correction_factors <- NULL
for(i in 1:2){
correction_factors[i] <- as.data.frame(lapply(List_DP2, function(x) get(paste0("ind_", tablas[i]))$correction_factors))
}
###Intetar de pegar el nombre de la columna 
correction_factors <- do.call(cbind.data.frame, c(Variables_sort, correction_factors)) %>%
                        subset(., select = c(1, 3, 2, 4))
colnames(correction_factors) <- c("Ind_2010", "2010", "Ind_2020", "2020")
```


```{r, echo = FALSE}
correction_factors %>%
  gt() %>%
   tab_header(title = "Correction Factors") %>%
    tab_options(heading.title.font.size = 14, 
                heading.align = "center",
                heading.subtitle.font.size = 12,
                table.align = "center",
                table.font.names = 'Century Gothic',
                table.font.size = 10,
                data_row.padding = px(1)) %>%
      tab_style(style = list(cell_text(align = "center",
                                       weight = 'bold')),
                locations = list(cells_title(groups = c("title")))) %>%
       cols_label(`Ind_2010` = md("**Ind**"), 
                  `2010` = md("**2010**"),
                  `Ind_2020` = md("**Ind**"),
                  `2020` = md("**2020**")) %>%
        fmt_number(columns = c(2, 4), decimals = 4) %>%
         cols_width(everything() ~ px(80)) %>%
          as_raw_html()        
```


## Coeficiente de Discriminación  {-}

El coeficiente de discriminación de Ivanovic mide el poder discriminante de la variable $j$ en el conjunto de observaciones $i$. 

$$CD_{j}=\frac{2}{m\left(m-1\right)}\sum_{i,l>i}^{k_{j}}m_{ij}m_{lj}\left|\frac{x_{ij}-x_{lj}}{{\overline{X}}_{i}}\right|$$

donde: 

$\circ\:m_{ij}$: El número de observaciones de la variable $x_{j}$    
$\circ\:k_{j}$: El número de diferentes valores que toma $x_{i}$ en el conjunto $j$.     


Esta medida está comprendida entre $[0, 2]$. Si una variable toma el mismo valor para todos los estados, el `CD` vale cero, indicando que posee un valor nulo de poder discriminante. Por el contrario, si una variable toma el valor teórico de máximo poder discriminante, el discriminante de la variable es total.   

**Se crea un data.frame de acuerdo al Coeficiente de discriminación (`CD`) de cada indicador parcial para todos los años**

```{r}
discrimination_coefficient <- NULL
discrimination_coefficient <- lapply(1:2, function(i) data.frame(names(get(paste0("ind_", tablas[i]))[["discrimination.coefficient"]]),
                                                                 get(paste0("ind_", tablas[i]))$discrimination.coefficient))

discrimination_coefficient <- do.call(cbind.data.frame, discrimination_coefficient)
colnames(discrimination_coefficient) <- c("Ind_2010", "2010", "Ind_2020", "2020")
```


```{r, echo = FALSE}
discrimination_coefficient %>%
  gt() %>%
   tab_header(title = "Discrimination Coefficient") %>%
    tab_options(heading.title.font.size = 14, 
                heading.align = "center",
                heading.subtitle.font.size = 12,
                table.align = "center",
                table.font.names = 'Century Gothic',
                table.font.size = 10,
                data_row.padding = px(1)) %>%
      tab_style(style = list(cell_text(align = "center",
                                       weight = 'bold')),
                locations = list(cells_title(groups = c("title")))) %>%
       cols_label(`Ind_2010` = md("**Ind**"), 
                  `2010` = md("**2010**"),
                  `Ind_2020` = md("**Ind**"),
                  `2020` = md("**2020**")) %>%
        fmt_number(columns = c(2, 4), decimals = 3) %>%
         cols_width(everything() ~ px(80)) %>%
          as_raw_html()        
```

## “Cantidad de Información Global de Ivanovic Pena Relativa Individual” {-}

$$\alpha_{i}=\frac{CD_{i}\left(1-R^{2}_{i,i-1,...,1} \right)}{\sum_{i=1}^{n}CD_{i} \left(1-R^{2}_{i,i-1,...,1} \right)}$$
Esta medida, comprendida entre 0 y 1, combina la información útil y el poder discriminante de cada indicador simple y mide la cantidad de información (combinada) relativa que aporta individualmente cada indicador simple, cuando entra de forma ordenada a formar parte del indicador sintético DP2. La suma de todos los valores de $\alpha_{i}$ es la unidad. [Zarsosa 1996, págs 158-174]      

```{r}
alpha <- NULL
for(i in 1:2){
alpha[[i]] <- sapply(1:length(Indicadores), function(x)(get(paste0("ind_", tablas[i]))[["correction_factors"]][x] * get(paste0("ind_", tablas[i]))[["discrimination.coefficient"]][x]) /                                                         sum(get(paste0("ind_", tablas[i]))[["correction_factors"]] * get(paste0("ind_", tablas[i]))[["discrimination.coefficient"]]))
}
```

```{r, echo = FALSE}
tabla <- NULL
for(i in 1:2){
tabla[[i]] <- data.frame(Variables = names(alpha[[i]]), alpha[[i]])
}

alpha<- do.call(cbind.data.frame, tabla)
colnames(alpha) <- c("Ind_2010", "2010", "Ind_2020", "2020")

alpha %>%
  gt() %>%
   tab_header(title = md("Cantidad de Información Global de Ivanovic Pena Relativa Individual")) %>%
    tab_options(heading.title.font.size = 14, 
                heading.align = "center",
                heading.subtitle.font.size = 12,
                table.align = "center",
                table.font.names = 'Century Gothic',
                table.font.size = 10,
                data_row.padding = px(1)) %>%
      tab_style(style = list(cell_text(align = "center",
                                       weight = 'bold')),
                locations = list(cells_title(groups = c("title")))) %>%
       cols_label(`Ind_2010` = md("**Ind**"), 
                  `2010` = md("**2010**"),
                  `Ind_2020` = md("**Ind**"),
                  `2020` = md("**2020**")) %>%
        fmt_number(columns = c(2, 4), decimals = 3) %>%
         cols_width(everything() ~ px(80)) %>%
          as_raw_html()        
```


<!--chapter:end:07-Validacion.Rmd-->

```{r include=FALSE, cache=FALSE}
# example R options set globally
options(width = 80)

# example chunk options set globally
knitr::opts_chunk$set(
  comment = "#>",
  collapse = TRUE,
  message = FALSE,
  warning = FALSE
  )
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
setwd(here::here())

```
# Resumen  {.unlisted .unnumbered}

```{r, echo = FALSE}
for(i in tablas){
load(file = paste0(here::here(), "/Output/IML_", i, ".RData"))
}

p <- NULL
for(i in 1:2){
nombres <- names(get(paste0("DP2_", tablas[i])))
p[[paste(tablas[i])]] <- get(paste0("DP2_", tablas[i])) %>%
                           group_by(get(nombres[19])) %>%
                             summarise(POB_TOT = sum(get(nombres[8])),
                                       GM = n())
}
p <- do.call(cbind.data.frame, p)

tabla <- p %>%
          select(-c("2020.get(nombres[19])")) %>%
           janitor::adorn_totals(fill = "-", where= "row")

tabla %>% 
 gt() %>%
  tab_header(title = "Nacional: Población y unidades geograficas según el índice de marginación, 2010-2020") %>%
   tab_options(heading.title.font.size = 14, 
               heading.subtitle.font.size = 12,
               table.font.names = 'Century Gothic',
               table.align = "center",
               table.font.size = 10,
               data_row.padding = px(1)) %>%
     tab_style(style = list(cell_text(align = "left",
                                      weight = 'bold')),
               locations = list(cells_title(groups = c("title")))) %>%
     tab_style(style = list(cell_text(align = "left")),
               locations = list(cells_title(groups = c("subtitle")))) %>%
     tab_style(style = list(cell_text(weight = 'bold')),
               locations = cells_body(columns = everything(), rows = tidyselect::last_col())) %>%
      cols_label(`2010.POB_TOT` = md("**Población 2010**"),
                 `2020.POB_TOT` = md("**Población 2020**"),
                 `2010.GM` = md("**Localidades**"),
                 `2020.GM` = md("**Localidades**"),
                 "2010.get(nombres[19])" = md("**Grados**")) %>%
       fmt_integer(columns = c(2:5), sep_mark = " ") %>%
        tab_spanner(label = "2010",
                    columns = c(2:3)) %>%
        tab_spanner(label = "2020",
                    columns = c(4:5)) %>%
         as_raw_html() 
```

La tabla presenta una comparación temporal del grado de marginación a nivel de localidades en México, desagregada por el grado de marginación para los años 2010 y 2020. 

**Observaciones Clave**     

**2.- Disminución en Grados Medio y Alto:**\    

La población en grados de marginación Medio y Alto muestra una tendencia a la baja. En 2010, el 6.7% de la población residía en localidades con grado de marginación Medio, disminuyendo al 6.2% en 2020. Para el grado Alto, la población disminuyó del 3.0% en 2010 al 2.8% en 2020.    

**3.- Estabilidad en Grado Muy Bajo:**\    

La población en el grado de marginación Muy Bajo se mantuvo relativamente estable, con un ligero incremento. En 2010, el 75.5% de la población residía en localidades con este grado de marginación, aumentando ligeramente al 75.7% en 2020.     

**4.- Comparación entre Grados Muy Alto y Alto vs. Muy Bajo y Bajo:**\   

En términos generales, la mayoría de la población reside en localidades con grados de marginación Muy Bajo y Bajo. En 2010, el 89.4% de la población se encontraba en estos grados, aumentando ligeramente al 90.1% en 2020. Por otro lado, la población en grados de marginación Muy Alto y Alto representa una proporción mucho menor, con el 3.8% en 2010 y una ligera disminución al 3.7% en 2020.    

En resumen, la mayoría de la población reside en localidades con grados de marginación Muy Bajo y Bajo, representando más del 89% de la población en los años considerados. La población en grados de marginación Muy Alto y Alto, aunque ha tenido un pequeño incremento, sigue representando una porción mucho menor de la población total.     

En el escenario general, entre 2010 y 2020, se observa que la mayor parte de la población en México vive en localidades con grados de marginación Muy Bajo y Bajo, abarcando más del 89% de la población en ambos años. Esto indica una concentración significativa de la población en áreas con menores niveles de marginación. Sin embargo, hay un ligero aumento en la población que reside en localidades con un grado de marginación Muy Alto, lo cual podría ser motivo de mesura por los incrementos de población en estas localidades. En contraste, las localidades con grados de marginación Medio y Alto han visto una disminución en su proporción de la población total, lo que sugiere una leve mejora en esos niveles de marginación. En general, la tendencia muestra una estabilidad en los grados de marginación Muy Bajo y una pequeña reducción en los grados Alto y Medio, mientras que los grados Muy Alto y Bajo han visto incrementos en sus proporciones de población.    


## Mapa a nivel localidad {-}


```{r, echo=FALSE, out.width='100%', warning=FALSE, message=FALSE}
p <- readRDS(paste0(here::here(), "/Output/Mapa.rds"))
p
```


## Comparación en el tiempo {-}

<div style="height:500px;">
```{r, echo=FALSE, out.width='100%'}
readRDS(paste0(here::here(), "/Output/Mapas_2010-2020.rds"))
```
</div>

<!--chapter:end:08-Resumen.Rmd-->

```{r include=FALSE, cache=FALSE}
# example R options set globally
options(width = 80)

# example chunk options set globally
knitr::opts_chunk$set(
  comment = "#>",
  collapse = TRUE,
  message = FALSE,
  warning = FALSE
  )
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
setwd(here::here())

```
# Referencias  {.unlisted .unnumbered}

```{r echo = FALSE}
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
setwd(here::here())
``` 

Dalenius, T. (1950). The problem of optimum stratification. Scandinavian Actuarial J., 3-4, 203-13. Recuperado de: https://doi.org/10.1080/03461238.1950.10432042    
__________ y Hodges, J. L., Jr. (1959). Minimum variance stratification. Journal of the American Statistical Association, 54, 88-101.      
Gunning, P. y Horgan, J. M. (2004). A new algorithm for the construction of stratum boundaries in skewed populations. Survey Methodology, 30 (2), 159–166.   

Pena Trapero, J. B. (1977). Problemas de la medición del bienestar y conceptos afines. Una aplicación al Caso Español. I. N. E: Madrid.   

Somarriba, N. y Pena, B. (2009). Synthetic Indicators of Quality of Life in Europe. Social Indicators Research. Recuperado de: https://doi.org/10.1007/s11205-008-9356-y    
__________, Zarzosa, P. y Pena, T. (2013). La calidad de vida en la Unión Europea. Un análisis temporal por medio de indicadores sintéticos.    Congreso de la Asociación Española de Ciencia Regional. XXXIX Reunión de Estudios Regionales. Smart regions for a smarter growth strategy: new challenges of Regional Policy and potentials of cities to overcome a worldwide economic crisis. Recuperado de:  https://old.reunionesdeestudiosregionales.org/Oviedo2013/htdocs/pdf/p851.pdf     

Zarzosa, P. (1996). Aproximación a la medición del bienestar social. Secretario de Publicaciones: Valladolid.    
__________. (2009). Estimación de la pobreza en las comunidades autónomas españolas, mediante la distancia DP2 de Pena. Estudios de Economía Aplicada, 27 (2), 397–416.
__________. (2012). The Social Welfare in Spain before the Crisis: Territorial and Chronological Analysis. International Journal of Advances in Management and Economics 1 (4), 165-171.   
__________ y Somarriba, N. (2013). An Assessment of Social Welfare in Spain: Territorial Analysis Using a Synthetic Welfare Indicator. Social Indicators Research, 111, 1-23.    

 

```{r, collapse=FALSE}
sesion_info <- devtools::session_info()
```


```{r, echo = FALSE}
kable(dplyr::select(tibble::as_tibble(sesion_info$packages %>% dplyr::filter(attached == TRUE)),
                    c(package, loadedversion, source))) %>%
   kable_classic(full_width = TRUE, html_font = "Century Gothic", font_size = 10) 
```

<!--chapter:end:09-Bibliografias.Rmd-->

